# -*- coding: utf-8 -*-
"""bank_marketing.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1XYTHfpSeEVZIL11lP_qdUScvWV4P8iyh

### Import library yang dibutuhkan
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

"""### Import data csv ke **DataFrame**"""

df = pd.read_csv('bank-full.csv', sep=';')
df

"""## Data Understanding

### Assessing Data
"""

df.info()

"""Disini diketahui bahwa data tidak memiliki missing values. Data terbagi menjadi data categorical dan numerical."""

df.describe()

"""- Age (Usia):
Rata-rata usia nasabah adalah sekitar 40 tahun, dengan rentang usia antara 18 hingga 95 tahun.
Sebagian besar nasabah berada di rentang usia antara 33 hingga 48 tahun, dengan kuartil pertama (25%) berada di usia 33 tahun dan kuartil ketiga (75%) berada di usia 48 tahun.

- Balance (Saldo):
Rata-rata saldo nasabah adalah sekitar 1362 unit, dengan rentang saldo yang sangat bervariasi, mulai dari negatif hingga lebih dari 100.000 unit.
Sebagian besar nasabah memiliki saldo yang relatif kecil, dengan nilai saldo kuartil pertama (25%) hanya sebesar 72 unit.

- Day (Hari):
Hari dalam bulan ketika kontak terakhir dilakukan berkisar dari 1 hingga 31.
Data menunjukkan bahwa kontak dilakukan sepanjang bulan, dengan tidak ada nilai yang mendominasi.

- Campaign (Kampanye):
Jumlah kontak kampanye yang dilakukan berkisar dari 1 hingga 63.
Sebagian besar nasabah menerima jumlah kontak yang relatif sedikit, dengan nilai kuartil pertama (25%) hanya sebesar 1.

- Pdays (Hari Terakhir Dicontact sejak Terakhir):
Jumlah hari yang telah berlalu sejak nasabah terakhir kali dihubungi berkisar dari -1 hingga lebih dari 800.
Nilai -1 menunjukkan bahwa nasabah belum pernah dihubungi sebelumnya, sedangkan nilai-nilai positif menunjukkan jumlah hari sejak kontak terakhir.

- Previous (Kontak Sebelumnya):
Jumlah kontak yang telah dilakukan sebelum kampanye saat ini berkisar dari 0 hingga 275.
Sebagian besar nasabah tidak memiliki kontak sebelumnya, dengan nilai kuartil pertama (25%) dan median (50%) adalah 0. Namun, ada sejumlah kecil nasabah yang memiliki jumlah kontak sebelumnya yang tinggi.-

### Exploratory Data Analysis (EDA)
"""

# Visualisasi kolom kategorikal
categorical_cols = df.select_dtypes(include=['object']).columns
categorical_cols.drop('y')

# Menghitung jumlah subplot yang diperlukan
cat_plots = len(categorical_cols)
cat_rows = (cat_plots - 1) // 3 + 1
cat_cols = min(cat_plots, 3)

fig, axs = plt.subplots(cat_rows, cat_cols, sharex=False, sharey=False, figsize=(20, 25))

counter = 0
for categorical_col in categorical_cols:
    value_counts = df[categorical_col].value_counts()

    trace_x = counter // 3
    trace_y = counter % 3
    x_pos = np.arange(0, len(value_counts))

    axs[trace_x, trace_y].bar(x_pos, value_counts.values, tick_label = value_counts.index)
    axs[trace_x, trace_y].set_title(categorical_col)

    for tick in axs[trace_x, trace_y].get_xticklabels():
        tick.set_rotation(90)

    counter += 1

plt.show()

# Visualisasi kolom numerik
numeric_cols = df.select_dtypes(include=['int64']).columns

# Menghitung jumlah subplot yang diperlukan
num_plots = len(numeric_cols)
num_rows = (num_plots - 1) // 3 + 1
num_cols = min(num_plots, 3)

fig, axs = plt.subplots(num_rows, num_cols, sharex=False, sharey=False, figsize=(15, 15))

counter = 0
for numeric_col in numeric_cols:
    trace_x = counter // 3
    trace_y = counter % 3

    axs[trace_x, trace_y].hist(df[numeric_col])
    axs[trace_x, trace_y].set_title(numeric_col)

    counter += 1
plt.show()

import pandas as pd
import matplotlib.pyplot as plt

numeric_cols = df.select_dtypes(include=['int64']).columns

# Split data menjadi dua dataframes berdasarkan kelas target
yes_df = df[df['y'] == 'yes']
no_df = df[df['y'] == 'no']

plt.figure(figsize=(16, 4))
for i, col in enumerate(df.select_dtypes(include=['int64']).columns):
    plt.subplot(1, len(df.select_dtypes(include=['int64']).columns), i + 1)
    yes_data = df[df['y'] == 'yes'][col]
    no_data = df[df['y'] == 'no'][col]
    plt.boxplot([yes_data, no_data], labels=['Yes', 'No'])
    plt.title(col)
plt.tight_layout()
plt.show()

"""Beberapa kolom seperti 'age', 'balance', 'duration', 'campaign', 'pdays', dan 'previous' memiliki distribusi yang tidak merata dan mengindikasikan adanya outlier. Ini akan ditangani menggunakan teknik winsorize."""

from scipy.stats.mstats import winsorize

# Winsorization untuk mengatasi outlier
numeric_cols = df.select_dtypes(include=['int64']).columns
for col in numeric_cols:
    df[col] = winsorize(df[col], limits=[0.05, 0.05])

# Plotting box plot setelah mengatasi outlier
plt.figure(figsize=(16, 4))
for i, col in enumerate(numeric_cols):
    plt.subplot(1, len(numeric_cols), i + 1)
    yes_data = df[df['y'] == 'yes'][col]
    no_data = df[df['y'] == 'no'][col]
    plt.boxplot([yes_data, no_data], labels=['Yes', 'No'])
    plt.title(col)
plt.tight_layout()
plt.show()

# Visualisasi kolom target
value_counts = df['y'].value_counts()

value_counts.plot.bar(title = 'Deposit value counts')

"""Diagram tersebut menunjukkan jumlah yang tidak seimbang antara kelas 'no' dan 'yes' pada data target. Ini akan ditangani menggunakan undersampling.

### Analisis kolom dengan target
"""

# job and deposit
job_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['job'].count()
total_no = df[df['y'] == 'no']['job'].count()

job_df['yes'] = df[df['y'] == 'yes']['job'].value_counts()
job_df['no'] = df[df['y'] == 'no']['job'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
job_yes_percentage = (job_df['yes'] / total_yes) * 100
job_no_percentage = (job_df['no'] / total_no) * 100

print(job_yes_percentage)
print(job_no_percentage)

job_df.plot.bar(title = 'Job and deposit')

"""Kategori pekerjaan "management" dan "admin" memiliki kemungkinan untuk mendaftar deposit berjangka. Persentase "yes" untuk kedua kategori ini lebih tinggi daripada persentase "no"."""

# marital status and deposit
marital_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['marital'].count()
total_no = df[df['y'] == 'no']['marital'].count()

marital_df['yes'] = df[df['y'] == 'yes']['marital'].value_counts()
marital_df['no'] = df[df['y'] == 'no']['marital'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
marital_yes_percentage = (marital_df['yes'] / total_yes) * 100
marital_no_percentage = (marital_df['no'] / total_no) * 100

print(marital_yes_percentage)
print(marital_no_percentage)

marital_df.plot.bar(title = 'Marital status and deposit')

""" Kategori status pernikahan yang kemungkinan memiliki target "yes" yang lebih tinggi adalah single. Persentase "yes" untuk status perkawinan "single" adalah 36.150501%, sedangkan persentase "no" hanya 27.248134%."""

# education and deposit
education_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['education'].count()
total_no = df[df['y'] == 'no']['education'].count()

education_df['yes'] = df[df['y'] == 'yes']['education'].value_counts()
education_df['no'] = df[df['y'] == 'no']['education'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
education_yes_percentage = (education_df['yes'] / total_yes) * 100
education_no_percentage = (education_df['no'] / total_no) * 100

print(education_yes_percentage)
print(education_no_percentage)

education_df.plot.bar(title = 'Education and deposit')

"""Berdasarkan data yang diberikan, kategori tingkat pendidikan yang kemungkinan memiliki target "yes" yang lebih tinggi adalah tertiary. Persentase "yes" untuk tingkat pendidikan "tertiary" adalah 37.738703%, sedangkan persentase "no" hanya 28.317720%."""

# type of contact and deposit
contact_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['contact'].count()
total_no = df[df['y'] == 'no']['contact'].count()

contact_df['yes'] = df[df['y'] == 'yes']['contact'].value_counts()
contact_df['no'] = df[df['y'] == 'no']['contact'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
contact_yes_percentage = (contact_df['yes'] / total_yes) * 100
contact_no_percentage = (contact_df['no'] / total_no) * 100

print(contact_yes_percentage)
print(contact_no_percentage)

contact_df.plot.bar(title = 'Type of contact and deposit')

"""Berdasarkan data yang diberikan, kategori jenis komunikasi yang kemungkinan memiliki target "yes" yang lebih tinggi adalah cellular. Oleh karena itu, menggunakan jenis komunikasi "cellular" lebih mungkin untuk menghasilkan nilai "yes" dalam target dibandingkan dengan jenis komunikasi lainnya."""

# type of housing and deposit
housing_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['housing'].count()
total_no = df[df['y'] == 'no']['housing'].count()

housing_df['yes'] = df[df['y'] == 'yes']['housing'].value_counts()
housing_df['no'] = df[df['y'] == 'no']['housing'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
housing_yes_percentage = (housing_df['yes'] / total_yes) * 100
housing_no_percentage = (housing_df['no'] / total_no) * 100

print(housing_yes_percentage)
print(housing_no_percentage)

housing_df.plot.bar(title = 'Type of housing and deposit')

"""Berdasarkan data yang diberikan, kategori status kepemilikan rumah yang kemungkinan memiliki target "yes" yang lebih tinggi adalah no. Oleh karena itu, individu yang tidak memiliki pinjaman rumah lebih mungkin untuk menghasilkan nilai "yes" dalam target dibandingkan dengan individu yang memiliki pinjaman rumah."""

# type of loan and deposit
loan_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['loan'].count()
total_no = df[df['y'] == 'no']['loan'].count()

loan_df['yes'] = df[df['y'] == 'yes']['loan'].value_counts()
loan_df['no'] = df[df['y'] == 'no']['loan'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
loan_yes_percentage = (loan_df['yes'] / total_yes) * 100
loan_no_percentage = (loan_df['no'] / total_no) * 100

print(loan_yes_percentage)
print(loan_no_percentage)

loan_df.plot.bar(title = 'Type of loan and deposit')

"""Berdasarkan data yang diberikan, kategori status pinjaman pribadi yang kemungkinan memiliki target "yes" yang lebih tinggi adalah no. Oleh karena itu, individu yang tidak memiliki pinjaman pribadi lebih mungkin untuk menghasilkan nilai "yes" dalam target dibandingkan dengan individu yang memiliki pinjaman pribadi."""

# type of default and deposit
default_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['default'].count()
total_no = df[df['y'] == 'no']['default'].count()

default_df['yes'] = df[df['y'] == 'yes']['default'].value_counts()
default_df['no'] = df[df['y'] == 'no']['default'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
default_yes_percentage = (default_df['yes'] / total_yes) * 100
default_no_percentage = (default_df['no'] / total_no) * 100

print(default_yes_percentage)
print(default_no_percentage)

default_df.plot.bar(title = 'Type of default and deposit')

"""Berdasarkan data yang diberikan, kategori status kredit dalam default yang kemungkinan memiliki target "yes" yang lebih tinggi adalah no. Oleh karena itu, individu yang tidak memiliki kredit dalam default lebih mungkin untuk menghasilkan nilai "yes" dalam target dibandingkan dengan individu yang memiliki kredit dalam default."""

# type of poutcome and deposit
poutcome_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['poutcome'].count()
total_no = df[df['y'] == 'no']['poutcome'].count()

poutcome_df['yes'] = df[df['y'] == 'yes']['poutcome'].value_counts()
poutcome_df['no'] = df[df['y'] == 'no']['poutcome'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
poutcome_yes_percentage = (poutcome_df['yes'] / total_yes) * 100
poutcome_no_percentage = (poutcome_df['no'] / total_no) * 100

print(poutcome_yes_percentage)
print(poutcome_no_percentage)

poutcome_df.plot.bar(title = 'Type of poutcome and deposit')

"""Berdasarkan data yang diberikan, kategori hasil kampanye pemasaran sebelumnya yang kemungkinan memiliki target "yes" yang lebih tinggi adalah success. Oleh karena itu, individu yang hasil kampanye pemasaran sebelumnya berhasil (success) lebih mungkin untuk menghasilkan nilai "yes" dalam target dibandingkan dengan kategori lainnya."""

# type of month and deposit
month_df = pd.DataFrame()

total_yes = df[df['y'] == 'yes']['month'].count()
total_no = df[df['y'] == 'no']['month'].count()

month_df['yes'] = df[df['y'] == 'yes']['month'].value_counts()
month_df['no'] = df[df['y'] == 'no']['month'].value_counts()

# Menghitung proporsi atau persentase untuk setiap kategori pekerjaan
month_yes_percentage = (month_df['yes'] / total_yes) * 100
month_no_percentage = (month_df['no'] / total_no) * 100

print(month_yes_percentage)
print(month_no_percentage)

month_df.plot.bar(title = 'Type of month and deposit')

"""Berdasarkan data yang diberikan, bulan dengan kemungkinan target "yes" yang lebih tinggi adalah bulan May (Mei). Ini menunjukkan bahwa pelanggan yang dihubungi pada bulan Mei cenderung lebih mungkin untuk menghasilkan "yes" dalam target dibandingkan dengan bulan-bulan lainnya.

## Data Preparation

Untuk fitur numerik akan dilakukan scaling menggunakan StandardScaler, sedangkan fitur kategorikal akan dilakukan one-hot encoding menggunakan OneHotEncoder
"""

from sklearn.preprocessing import OneHotEncoder
from sklearn.preprocessing import StandardScaler

# Memisahkan fitur kategorikal dan numerik
categorical_cols = df.select_dtypes(include=['object']).columns
categorical_cols = categorical_cols.drop('y')
numeric_cols = df.select_dtypes(include=['int64']).columns

# One-hot encoding pada fitur kategorikal
encoder = OneHotEncoder(sparse=False, handle_unknown='ignore')
encoded_data = encoder.fit_transform(df[categorical_cols])

# Membuat DataFrame baru dari data yang telah diencode
encoded_df = pd.DataFrame(encoded_data, columns=encoder.get_feature_names_out(categorical_cols))

# Standarisasi pada fitur numerik
scaler = StandardScaler()
scaled_data = scaler.fit_transform(df[numeric_cols])

# Membuat DataFrame baru dari data yang telah di-standarisasi
scaled_df = pd.DataFrame(scaled_data, columns=numeric_cols)

# Menggabungkan semua fitur
df = pd.concat([encoded_df, scaled_df, df['y']], axis=1)

df.head()

"""Melakukan Label Encoding pada kolom target 'y'. Yaitu mengubah 'yes' menjadi 0 dan 'no' menjadi 1"""

from sklearn.preprocessing import LabelEncoder

label_encoder = LabelEncoder()

# Melakukan label encoding pada target 'y'
df['y'] = label_encoder.fit_transform(df['y'])

df.head()

df.describe()

df.info()

"""Distribusi kelas pada target tidak seimbang, sehingga dilakukan undersampling"""

df['y'].value_counts()

from sklearn.utils import resample

# Memisahkan data menjadi kelas mayoritas dan minoritas
df_majority = df[df['y'] == 0]
df_minority = df[df['y'] == 1]

# Melakukan undersampling pada kelas mayoritas
undersampled_majority = resample(df_majority, replace=False, n_samples=len(df_minority), random_state=42)
df = pd.concat([df_minority, undersampled_majority])

df['y'].value_counts()

"""Split train dan test data dengan persentase 80% train dan 20% test data. Dipastikan juga bahwa jumlah distribusi kelas pada training dan testing sama, yaitu 50%."""

from sklearn.model_selection import train_test_split

# Membagi data menjadi data train dan data test dengan proporsi yang sama dengan Stratified Shuffle Split
X_train, X_test, y_train, y_test = train_test_split(df.drop(columns=['y']), df['y'], test_size=0.2, random_state=42, stratify=df['y'])

print("Proportion of target in train set:")
print(y_train.value_counts() / len(y_train))

print("\nProportion of target in test set:")
print(y_test.value_counts() / len(y_test))

"""## Data Modeling"""

from sklearn.linear_model import LogisticRegression
from sklearn.svm import SVC
from sklearn import tree
from sklearn.ensemble import RandomForestClassifier
import xgboost


dict_classifiers = {
     "Logistic Regression": LogisticRegression(),
    "Linear SVM": SVC(),
    "Decision Tree": tree.DecisionTreeClassifier(),
    "Random Forest": RandomForestClassifier(n_estimators=18),
    "xgb": xgboost.XGBClassifier()
}

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report

# Inisialisasi dictionary untuk menyimpan hasil akurasi
accuracy_results = {}

# Melakukan iterasi pada setiap model dan mengukur akurasi
for classifier_name, classifier in dict_classifiers.items():
    # Training model
    classifier.fit(X_train, y_train)

    # Prediksi pada data train
    train_pred = classifier.predict(X_train)

    # Prediksi pada data test
    test_pred = classifier.predict(X_test)

    # Mengukur akurasi pada data train dan data test
    train_accuracy = accuracy_score(y_train, train_pred)
    test_accuracy = accuracy_score(y_test, test_pred)

    # Menampilkan laporan klasifikasi
    print(f"Classifier: {classifier_name}")
    print(f"Train Accuracy: {train_accuracy:.4f}")
    print(f"Test Accuracy: {test_accuracy:.4f}")
    print("Classification Report on Test Data:")
    print(classification_report(y_test, test_pred))
    print()

    # Menyimpan hasil akurasi
    accuracy_results[classifier_name] = {'train_accuracy': train_accuracy, 'test_accuracy': test_accuracy}

"""
Berdasarkan hasil evaluasi tersebut, berikut adalah kesimpulan yang didapat:

- Logistic Regression: Model ini memiliki akurasi yang cukup baik di atas 80%. Precision, recall, dan f1-score untuk kelas positif (1) dan negatif (0) juga cukup seimbang, menunjukkan kinerja yang stabil.

- Linear SVM: Model ini memberikan akurasi yang tinggi, sedikit lebih baik dari Logistic Regression. Precision, recall, dan f1-score untuk kelas positif (1) dan negatif (0) juga cukup seimbang, menunjukkan kinerja yang stabil.

- Decision Tree: Meskipun model Decision Tree memiliki akurasi yang cukup tinggi, namun terdapat sedikit overfitting karena akurasi pada data train mencapai 100%. Selain itu, precision, recall, dan f1-score untuk kedua kelas cenderung seimbang, menunjukkan bahwa model ini dapat melakukan klasifikasi dengan baik.

- Random Forest: Model Random Forest memberikan akurasi yang baik dan cenderung mengurangi overfitting yang terjadi pada Decision Tree karena penggunaan ensemble learning. Precision, recall, dan f1-score untuk kedua kelas juga cukup seimbang, menunjukkan kinerja yang baik.

- XGBoost: XGBoost merupakan model terbaik dari semua model yang dievaluasi. Model ini memberikan akurasi yang tinggi dan kinerja yang stabil dengan precision, recall, dan f1-score yang seimbang untuk kedua kelas.

Dengan demikian, berdasarkan hasil evaluasi, dapat disimpulkan bahwa XGBoost adalah model terbaik untuk tugas klasifikasi ini, diikuti oleh Linear SVM dan Random Forest. Sedangkan Decision Tree cenderung overfitting, dan Logistic Regression memiliki performa yang cukup baik tetapi lebih rendah dibandingkan dengan model lainnya."""